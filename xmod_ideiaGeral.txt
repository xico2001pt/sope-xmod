xmod [options] mode file
          .      .     . ->diretorio ou file              
          .      .
           .     .
//xmod_info.h
struct xmod_info_t(){
    //ver disc
}
//xmod_info.c
    int fillXmodInfo()
    {
        
        identifyMode(); ->convtere modo não octal em octal
        identifyOptions();
        
    }
    int compareMode(newmode, oldmode)
    {

    }


//xmod.c
 main(int agrc, char* argv)
 {
    Iniciar contagem de tempo;
    if(argc > 4 || <= 5)
        perror()

    Verificar o modo pre-modificação;
    Abrir ficheiro LogFilename

    struct xmod_options_t options;

    fillXmodInfo(int argc, char* argv, &options);

    

    if(ter_R)
    {
        //recursivo
    }
    compareMode(options->mode, old);

    chmod(argv[argc-1], options->mode);
    addEvent(Evento, char* argv);
    writeOnCosole()
    
     
 }

//exemplo: (tirar modo antigo)
int main(int argc, char* argv[]){
    
    struct stat status;
    stat(argv[1], &status);

    printf("%o",status.st_mode);

    return 0;
    

}

    regist_new_event
    //Buscar o valor de ticks por clock
    long ticks =sysconf(_SC_CLK_TCK);
    //Calcular o nº de clocks entre o start e o chamar da função
    clock_t total_time = registration_instant - startClock;
    double time = total_time/ticks;
    

    char s[10];

    //convert total_time/ticks to string 
    sprintf(s,"%4.2f",time);

    //Escrever o instante
    if(write(logFile, s, strlen(s))==-1){
        //Error in write
        return -1;
    }
    //adiciona o ponto e virgula
    write(logFile, " ; ", 3);

    char lindo[20];
    //Transforma o pid em string para determinar o tamanho
    sprintf(lindo,"%d",pid);

    //Escrever o instante
    if(write(logFile, lindo, strlen(lindo))==-1){
        //Error in write
        return -1;
    }

    //adiuciona o ponto e virgula
    write(logFile, " ; ", 3);

    return 0;